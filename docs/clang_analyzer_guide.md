# Clang-based C/C++ Code Analyzer Guide

## Overview

This guide describes the Clang-based C/C++ code analysis system implemented in this project. This analyzer provides comprehensive analysis capabilities:

1. Full C++ support - Classes, namespaces, templates, and other modern C++ features
2. Accurate analysis - Uses AST analysis rather than string matching for high precision
3. Extensibility - Access to rich code information like variable types, template parameters
4. Graph visualization - Integration with Neo4j for powerful code visualization

## Installation

### Prerequisites

- Python 3.7+
- Clang and libclang
- Neo4j (optional, for graph database integration)

### Installing Clang and libclang

Clang and libclang are required for analyzing C++ code:

- **Linux**: Install using your package manager:
  ```bash
  # Ubuntu/Debian
  sudo apt-get install clang libclang-dev

  # Fedora/RHEL
  sudo dnf install clang clang-devel
  ```

- **Windows**: Install using LLVM installer from https://releases.llvm.org/
  1. Download the latest stable release
  2. Run the installer and follow the instructions
  3. Make sure to add LLVM to your system PATH

- **macOS**: Install using Homebrew:
  ```bash
  brew install llvm
  ```

### Installing Python Dependencies

Install the required Python packages:

```bash
# Using UV (recommended)
uv pip install -r requirements.txt

# Or using standard pip
pip install -r requirements.txt
```

## Using the Analyzer

### Command Line Interface

The modular command line interface supports comprehensive Clang analysis:

```bash
# Index a single file
python -m src index path/to/file.cpp --project myproject --use-clang

# Index an entire directory
python -m src index path/to/directory --project myproject --use-clang --clear

# Add include directories and compiler arguments
python -m src index path/to/file.cpp --project myproject --use-clang \
    --include-dirs /usr/include /usr/local/include \
    --compiler-args -std=c++17 -DDEBUG
```

### Consolidated Indexing Tools

The indexing tools have been consolidated into a single module in the `test_scripts` directory:

```bash
python test_scripts/indexing_tools.py <command> [options]
```

Available commands include:
- `index`: Index a file or directory
- `index-incremental`: Incrementally index a directory
- `index-folly`: Index the Folly codebase (with appropriate settings)
- `clear`: Clear project data from Neo4j

Examples:
```bash
# Index a directory with specific options
python test_scripts/indexing_tools.py index path/to/directory --project myproject --clear --use-clang

# Incrementally update an indexed codebase
python test_scripts/indexing_tools.py index-incremental path/to/directory --project myproject

# Index Folly codebase with optimized settings
python test_scripts/indexing_tools.py index-folly path/to/folly
```

### Using Compile Commands Database

For projects with a `compile_commands.json` file (generated by build systems like CMake):

```bash
python -m src index path/to/project --project myproject --use-clang --use-compile-commands
```

The analyzer will automatically extract include paths and compiler arguments from the compilation database.

### Cross-file Analysis

The analyzer supports several modes of cross-file analysis:

```bash
# Basic mode - faster but less precise
python -m src index path/to/directory --project myproject --use-clang --cross-file-mode basic

# Enhanced mode - balanced approach
python -m src index path/to/directory --project myproject --use-clang --cross-file-mode enhanced

# Full mode - slower but more precise
python -m src index path/to/directory --project myproject --use-clang --cross-file-mode full
```

### Advanced C++ Features

Enable special handling for advanced C++ features:

```bash
# Enable template specialization tracking
python -m src index path/to/directory --project myproject --use-clang --enhanced-template-handling

# Enable virtual method tracking
python -m src index path/to/directory --project myproject --use-clang --track-virtual-methods
```

## Configuration Settings

The analyzer can be configured via command line options and configuration files:

### Include Paths

Include paths can be specified in several ways:
- Via command line: `--include-dirs /path/to/include`
- In compile_commands.json (recommended)
- Automatically detected by the analyzer

### Compiler Arguments

Compiler arguments affect how code is parsed:
- C++ standard: `-std=c++17`
- Macro definitions: `-DDEBUG`
- System includes: `-isystem /path/to/system/include`

### Cross-file Analysis

Choose the appropriate cross-file analysis mode:
- `basic`: Fast analysis with limited cross-file resolution
- `enhanced`: Balanced approach with name-based matching
- `full`: Comprehensive analysis with signature-based matching

## Internal Architecture

The Clang analyzer consists of several key components:

### ClangAnalyzerService

The main service that coordinates the analysis:
- Manages libclang interactions
- Processes source files and extracts information
- Builds the call graph

### CompileCommandsService

Handles compile_commands.json processing:
- Extracts include paths and compiler arguments
- Maps files to their compilation settings
- Provides fallback mechanisms

### Function and CallGraph Models

Data structures for storing analysis results:
- Function: Stores information about a single function
- CallGraph: Maintains the relationships between functions

### Neo4jService

Stores analysis results in Neo4j:
- Represents functions as nodes
- Creates relationships for function calls, inheritance, etc.
- Supports incremental updates

## Limitations and Workarounds

### Known Issues

1. **Complex templates**: The analyzer may have difficulty with highly complex template metaprogramming
   - Workaround: Use `--enhanced-template-handling` for better results

2. **Include path configuration**: Incorrect include paths can cause parsing failures
   - Workaround: Use compile_commands.json or specify paths manually

3. **Large codebase performance**: Analysis of very large codebases can be slow
   - Workaround: Use parallel processing and incremental indexing

4. **Platform-specific code**: Code with platform-specific macros may parse differently
   - Workaround: Define appropriate macros using `--compiler-args`

### Troubleshooting

If you encounter issues:

1. Verify libclang installation:
   ```bash
   python find_libclang.py
   ```

2. Check include paths are correct:
   ```bash
   python -m src index path/to/file.cpp --project test --use-clang --verbose
   ```

3. Try with explicit include directories:
   ```bash
   python -m src index path/to/file.cpp --include-dirs /path/to/headers
   ```

4. Enable debug logging:
   ```bash
   python -m src index path/to/file.cpp --debug
   ```

## Advanced Usage

### Programmatic API

Access the analyzer programmatically:

```python
from src.services.clang_analyzer_service import ClangAnalyzerService
from src.models.call_graph import CallGraph

# Create analyzer
analyzer = ClangAnalyzerService()

# Analyze a file
call_graph = analyzer.analyze_file(
    file_path="path/to/file.cpp",
    include_dirs=["/path/to/include"],
    compiler_args=["-std=c++17"],
    analyze_templates=True
)

# Analyze a directory
call_graph = analyzer.analyze_directory(
    directory_path="path/to/directory",
    include_dirs=["/path/to/include"],
    compiler_args=["-std=c++17"],
    parallel=True,
    max_workers=4
)

# Index in Neo4j
from src.services.neo4j_service import Neo4jService
neo4j = Neo4jService()
neo4j.index_call_graph(call_graph, "my_project", clear=True)
```

### Customizing the Analysis

Customize the analysis to focus on specific aspects:

```python
# Focus on template specializations
call_graph = analyzer.analyze_file(
    file_path="path/to/file.cpp",
    analyze_templates=True
)

# Track virtual methods and override relationships
call_graph = analyzer.analyze_file(
    file_path="path/to/file.cpp",
    track_virtual_methods=True
)

# Customize cross-file resolution
call_graph = analyzer.analyze_directory(
    directory_path="path/to/directory",
    cross_file_mode="enhanced"  # Options: "basic", "enhanced", "full"
)
```

## Integration with Other Tools

### Integration with Build Systems

The analyzer can be integrated with various build systems:

- **CMake**: Generate compile_commands.json with `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON`
- **Make**: Use tools like Bear to generate compile_commands.json
- **Visual Studio**: Use tools like VSCompDB to generate compile_commands.json

### Integration with CI/CD Pipelines

Example integration with CI/CD pipelines:

```yaml
# Example GitHub Actions workflow
name: Analyze Code

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: '3.10'
      - name: Install dependencies
        run: |
          sudo apt-get install -y clang libclang-dev
          pip install -r requirements.txt
      - name: Analyze codebase
        run: python -m src index ./src --project myproject --use-clang --parallel
      - name: Generate reports
        run: python test_scripts/visualization_tools.py --type component_summary
```

## Visualization and Exploration

The analyzer can be used in conjunction with the visualization tools:

### Function Call Graphs

Generate call graphs for specific functions:

```bash
python test_scripts/visualization_tools.py --type specific_component --component Future
```

### Project-wide Analysis

Analyze the overall structure of a project:

```bash
python test_scripts/visualization_tools.py --type folly_callgraph
```

### Cypher Queries in Neo4j

Execute custom Cypher queries to explore specific aspects of the code:

```cypher
// Find functions that are called by many other functions (hotspots)
MATCH (f:Function)<-[r:CALLS]-()
RETURN f.name as function_name, COUNT(r) AS caller_count
ORDER BY caller_count DESC
LIMIT 10

// Find classes with the most methods
MATCH (f:Function)
WHERE f.is_method = true
RETURN f.class_name as class_name, COUNT(f) AS method_count
ORDER BY method_count DESC
LIMIT 10

// Find function call chains (paths)
MATCH path = (start:Function)-[:CALLS*1..3]->(end:Function)
WHERE start.name = 'main'
RETURN path
LIMIT 100
```

## Conclusion

The Clang analyzer provides a powerful way to analyze C++ codebases, with support for advanced C++ features and integration with Neo4j for visualization and analysis. The consolidated tools provide a simplified workflow for common tasks. 