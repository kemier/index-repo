"""
Utilities for parsing compile_commands.json and extracting compiler flags.

This module provides functionality to extract include paths and other compiler
flags from compile_commands.json files, which are commonly generated by
CMake, Ninja, and other build systems.
"""
import os
import json
import shlex
import platform
import subprocess
from pathlib import Path
from typing import List, Dict, Set, Optional, Tuple


def extract_include_paths(compile_commands_path: str) -> List[str]:
    """
    Extract include paths from compile_commands.json.
    
    Args:
        compile_commands_path: Path to compile_commands.json file
        
    Returns:
        List of include paths
    """
    include_paths = set()
    
    try:
        with open(compile_commands_path, 'r', encoding='utf-8') as f:
            commands = json.load(f)
            
        if not isinstance(commands, list):
            print(f"Warning: Invalid compile_commands.json format at {compile_commands_path}")
            return []
            
        for cmd in commands:
            if not isinstance(cmd, dict) or 'command' not in cmd:
                continue
                
            args = shlex.split(cmd['command'])
            directory = cmd.get('directory', '')
            
            for i, arg in enumerate(args):
                if arg.startswith('-I'):
                    # Handle -Ipath format
                    path = arg[2:]
                    if not os.path.isabs(path):
                        path = os.path.normpath(os.path.join(directory, path))
                    include_paths.add(path)
                elif arg == '-I' and i+1 < len(args):
                    # Handle -I path format
                    path = args[i+1]
                    if not os.path.isabs(path):
                        path = os.path.normpath(os.path.join(directory, path))
                    include_paths.add(path)
                # Also handle system include paths with -isystem
                elif arg.startswith('-isystem'):
                    path = arg[8:]
                    if not os.path.isabs(path):
                        path = os.path.normpath(os.path.join(directory, path))
                    include_paths.add(path)
                elif arg == '-isystem' and i+1 < len(args):
                    path = args[i+1]
                    if not os.path.isabs(path):
                        path = os.path.normpath(os.path.join(directory, path))
                    include_paths.add(path)
    
    except Exception as e:
        print(f"Error extracting include paths from {compile_commands_path}: {e}")
        
    return list(include_paths)


def extract_compiler_args(compile_commands_path: str, file_path: Optional[str] = None) -> List[str]:
    """
    Extract compiler arguments for a specific file or all files.
    
    Args:
        compile_commands_path: Path to compile_commands.json file
        file_path: Path to source file to extract args for (or None for all)
        
    Returns:
        List of compiler arguments
    """
    compiler_args = set()
    
    try:
        with open(compile_commands_path, 'r', encoding='utf-8') as f:
            commands = json.load(f)
            
        if not isinstance(commands, list):
            return []
            
        for cmd in commands:
            if not isinstance(cmd, dict) or 'command' not in cmd:
                continue
                
            # If file_path is specified, only extract args for that file
            if file_path and cmd.get('file') != file_path:
                continue
                
            args = shlex.split(cmd['command'])
            
            # Extract all relevant compiler flags
            i = 0
            while i < len(args):
                arg = args[i]
                
                # Skip compiler executable
                if i == 0 or arg.endswith('gcc') or arg.endswith('g++') or arg.endswith('clang') or arg.endswith('clang++'):
                    i += 1
                    continue
                    
                # Include flags
                if arg.startswith('-I'):
                    compiler_args.add(arg)
                    i += 1
                elif arg == '-I' and i+1 < len(args):
                    compiler_args.add(f"-I{args[i+1]}")
                    i += 2
                # System include flags
                elif arg.startswith('-isystem'):
                    compiler_args.add(arg)
                    i += 1
                elif arg == '-isystem' and i+1 < len(args):
                    compiler_args.add(f"-isystem{args[i+1]}")
                    i += 2
                # Define flags
                elif arg.startswith('-D'):
                    compiler_args.add(arg)
                    i += 1
                # Standard flags
                elif arg.startswith('-std='):
                    compiler_args.add(arg)
                    i += 1
                # Other common flags
                elif arg.startswith('-f') or arg.startswith('-W'):
                    compiler_args.add(arg)
                    i += 1
                # Platform specific flags
                elif arg.startswith('-m'):  # Architecture flags like -m64
                    compiler_args.add(arg)
                    i += 1
                else:
                    i += 1
    
    except Exception as e:
        print(f"Error extracting compiler args from {compile_commands_path}: {e}")
        
    return list(compiler_args)


def detect_project_include_paths(project_root: str) -> List[str]:
    """
    Automatically detect include paths for a project.
    
    Args:
        project_root: Path to project root directory
        
    Returns:
        List of detected include paths
    """
    include_paths = []
    
    # 1. Check for compile_commands.json in common locations
    compile_commands_paths = [
        os.path.join(project_root, 'compile_commands.json'),
        os.path.join(project_root, 'build', 'compile_commands.json'),
        os.path.join(project_root, 'out', 'compile_commands.json'),
        os.path.join(project_root, '.vscode', 'compile_commands.json'),
        os.path.join(project_root, 'cmake-build-debug', 'compile_commands.json'),
        os.path.join(project_root, 'cmake-build-release', 'compile_commands.json')
    ]
    
    for cc_path in compile_commands_paths:
        if os.path.exists(cc_path):
            extracted_paths = extract_include_paths(cc_path)
            include_paths.extend(extracted_paths)
            if extracted_paths:
                print(f"Found include paths from {cc_path}")
    
    # 2. If no compile_commands.json found, try common directories
    if not include_paths:
        common_include_dirs = [
            '',  # Project root itself
            'include',
            'inc',
            'src',
            'lib',
            'source',
            'third_party',
            'external',
            'deps',
            'vendor'
        ]
        
        for include_dir in common_include_dirs:
            path = os.path.join(project_root, include_dir)
            if os.path.isdir(path):
                include_paths.append(path)
        
        # 3. Try to infer include paths by scanning for header files
        include_paths.extend(find_include_directories_by_scanning(project_root))
    
    # 4. Add system include paths based on the platform
    system_include_paths = detect_system_include_paths()
    include_paths.extend(system_include_paths)
    
    # Remove duplicates while preserving order
    seen = set()
    unique_include_paths = []
    for path in include_paths:
        if path not in seen:
            seen.add(path)
            unique_include_paths.append(path)
    
    return unique_include_paths


def find_include_directories_by_scanning(project_root: str) -> List[str]:
    """
    Find include directories by scanning for .h/.hpp files.
    
    Args:
        project_root: Project root directory
        
    Returns:
        List of discovered include directories
    """
    include_dirs = set()
    header_extensions = ['.h', '.hpp', '.hxx', '.hh']
    
    # Keep track of directories with more than N header files
    dir_header_count = {}
    
    for root, dirs, files in os.walk(project_root):
        # Skip hidden directories and common build/output directories
        dirs[:] = [d for d in dirs if not d.startswith('.') and 
                  d not in ['build', 'out', 'bin', 'obj', 'node_modules', '.git']]
        
        # Count header files in this directory
        header_count = sum(1 for f in files if any(f.endswith(ext) for ext in header_extensions))
        
        if header_count > 0:
            dir_header_count[root] = header_count
    
    # Consider directories with significant header files (threshold: 3)
    for directory, count in dir_header_count.items():
        if count >= 3:
            include_dirs.add(directory)
            
            # Also check if there's a canonical "include" pattern
            if os.path.basename(directory) in ['include', 'inc', 'headers']:
                include_dirs.add(directory)
    
    return list(include_dirs)


def detect_system_include_paths() -> List[str]:
    """
    Detect system include paths based on the platform and installed compilers.
    
    Returns:
        List of system include paths
    """
    system_paths = []
    
    system = platform.system()
    if system == "Linux":
        # Common Linux system include paths
        system_paths.extend([
            "/usr/include",
            "/usr/local/include"
        ])
        
        # Try to get GCC or Clang include paths
        try:
            if subprocess.run(['which', 'gcc'], stdout=subprocess.PIPE, stderr=subprocess.PIPE).returncode == 0:
                output = subprocess.check_output(['gcc', '-xc++', '-E', '-v', '/dev/null'], 
                                               stderr=subprocess.STDOUT, 
                                               universal_newlines=True)
                paths = parse_compiler_output_for_includes(output)
                system_paths.extend(paths)
        except Exception:
            pass
            
    elif system == "Darwin":  # macOS
        # Common macOS system include paths
        system_paths.extend([
            "/usr/include",
            "/usr/local/include",
            "/Library/Developer/CommandLineTools/usr/include/c++/v1"
        ])
        
        # Try to get Clang include paths
        try:
            output = subprocess.check_output(['clang++', '-xc++', '-E', '-v', '/dev/null'], 
                                           stderr=subprocess.STDOUT, 
                                           universal_newlines=True)
            paths = parse_compiler_output_for_includes(output)
            system_paths.extend(paths)
        except Exception:
            pass
            
    elif system == "Windows":
        # Common Windows system include paths
        if "INCLUDE" in os.environ:
            system_paths.extend(os.environ["INCLUDE"].split(os.pathsep))
            
        # Visual Studio paths
        program_files = os.environ.get("ProgramFiles", "C:\\Program Files")
        vs_paths = [
            os.path.join(program_files, "Microsoft Visual Studio", "2022", "Community", "VC", "Tools", "MSVC"),
            os.path.join(program_files, "Microsoft Visual Studio", "2019", "Community", "VC", "Tools", "MSVC"),
            os.path.join(program_files, "Microsoft Visual Studio", "2017", "Community", "VC", "Tools", "MSVC")
        ]
        
        for vs_path in vs_paths:
            if os.path.exists(vs_path):
                # Find the latest MSVC version
                msvc_versions = [d for d in os.listdir(vs_path) if os.path.isdir(os.path.join(vs_path, d))]
                if msvc_versions:
                    latest_version = sorted(msvc_versions)[-1]
                    msvc_include = os.path.join(vs_path, latest_version, "include")
                    if os.path.exists(msvc_include):
                        system_paths.append(msvc_include)
    
    return system_paths


def parse_compiler_output_for_includes(output: str) -> List[str]:
    """
    Parse compiler verbose output to extract include paths.
    
    Args:
        output: Compiler output string
        
    Returns:
        List of include paths
    """
    include_paths = []
    in_include_section = False
    
    for line in output.splitlines():
        line = line.strip()
        
        if line == "#include <...> search starts here:":
            in_include_section = True
            continue
            
        if line == "End of search list.":
            in_include_section = False
            continue
            
        if in_include_section and line:
            include_paths.append(line)
    
    return include_paths


def extract_macros_from_compile_commands(compile_commands_path: str) -> Dict[str, str]:
    """
    Extract macro definitions from compile_commands.json.
    
    Args:
        compile_commands_path: Path to compile_commands.json file
        
    Returns:
        Dictionary of macro names to values
    """
    macros = {}
    
    try:
        with open(compile_commands_path, 'r', encoding='utf-8') as f:
            commands = json.load(f)
            
        if not isinstance(commands, list):
            return {}
            
        for cmd in commands:
            if not isinstance(cmd, dict) or 'command' not in cmd:
                continue
                
            args = shlex.split(cmd['command'])
            
            for i, arg in enumerate(args):
                if arg.startswith('-D'):
                    define = arg[2:]
                    if '=' in define:
                        name, value = define.split('=', 1)
                        macros[name] = value
                    else:
                        macros[define] = "1"  # Default value for defined macros without explicit value
                elif arg == '-D' and i+1 < len(args):
                    define = args[i+1]
                    if '=' in define:
                        name, value = define.split('=', 1)
                        macros[name] = value
                    else:
                        macros[define] = "1"
    
    except Exception as e:
        print(f"Error extracting macros from {compile_commands_path}: {e}")
        
    return macros 